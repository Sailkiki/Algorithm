# 第一章：基本排序技术

## 冒泡排序：

时间复杂度 O(n²)

```c++
void BubbleSort(int *arr, int len){
     int temp;//临时变量
     for(int i=0; i<len-1; i++){   //表示趟数，一共arr.length-1次。
         for(int j=len-1; j>i; j--){

             if(arr[j] < arr[j-1]){
                 temp = arr[j];
                 arr[j] = arr[j-1];
                 arr[j-1] = temp;
             }
         }
     }
 }
```

优化：设置flag， 避免重复比较

```c++
void ~(int *arr， int len){

   int temp;//临时变量
   bool flag = false;//是否交换的标志
   for(int i=0; i<len-1; i++){   //表示趟数，一共 arr.length-1 次

       // 每次遍历标志位都要先置为false，才能判断后面的元素是否发生了交换
       flag = false;
       
       for(int j=len-1; j>i; j--){ //选出该趟排序的最大值往后移动

           if(arr[j] < arr[j-1]){
               temp = arr[j];
               arr[j] = arr[j-1];
               arr[j-1] = temp;
               flag = true;    //只要有发生了交换，flag就置为true
           }
       }
       // 判断标志位是否为false，如果为false，说明后面的元素已经有序，就直接return
       if(!flag) break;
   }
}
```



## 选择排序

时间复杂度 O(n²)

```java
public static void select_sort(int array[],int lenth){

   for(int i=0;i<lenth-1;i++){

       int minIndex = i;
       for(int j=i+1;j<lenth;j++){
          if(array[j]<array[minIndex]){
              minIndex = j;
          }
       }
       if(minIndex != i){
           int temp = array[i];
           array[i] = array[minIndex];
           array[minIndex] = temp;
       }
   }
}
```

## 插入排序

**平均时间复杂度：**O(n2)

```java
public static void  insert_sort(int array[],int lenth){

   int temp;

   for(int i=0;i<lenth-1;i++){
       for(int j=i+1;j>0;j--){
           if(array[j] < array[j-1]){
               temp = array[j-1];
               array[j-1] = array[j];
               array[j] = temp;
           }else{         //不需要交换
               break;
           }
       }
   }
}
```

## 希尔排序

O(n1.5)

```java
public static void shell_sort(int array[],int lenth){

   int temp = 0;
   int incre = lenth;

   while(true){
       incre = incre/2;

       for(int k = 0;k<incre;k++){    //根据增量分为若干子序列

           for(int i=k+incre;i<lenth;i+=incre){

               for(int j=i;j>k;j-=incre){
                   if(array[j]<array[j-incre]){
                       temp = array[j-incre];
                       array[j-incre] = array[j];
                       array[j] = temp;
                   }else{
                       break;
                   }
               }
           }
       }

       if(incre == 1){
           break;
       }
   }
}
```

## 快速排序

**平均时间复杂度：**O(N*logN)

```c++
void quick_sort(int s[], int l, int r)
{
    if (l < r)
    {
        //Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注1
        int i = l, j = r, x = s[l];
        while (i < j)
        {
            while(i < j && s[j] >= x) // 从右向左找第一个小于x的数
                j--;  
            if(i < j) 
                s[i++] = s[j];
            
            while(i < j && s[i] < x) // 从左向右找第一个大于等于x的数
                i++;  
            if(i < j) 
                s[j--] = s[i];
        }
        s[i] = x;
        quick_sort(s, l, i - 1); // 递归调用 
        quick_sort(s, i + 1, r);
    }
}
```

当数据比较强的话：

```c++
#include<iostream>

using namespace std;

const int N = 1e5+ 10;

int n;
int q[N]; 

void quick_sort(int q[], int l, int r)
{
    if(l >= r) return;

    int x = q[l+r>>1], i = l - 1, j = r + 1;
    while(i < j){
        do i++ ; while(q[i] < x);
        do j-- ; while(q[j] > x);
        if(i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}

int main(){
    scanf("%d", &n);
    for(int i = 0; i < n; i++) scanf("%d", &q[i]);

    quick_sort(q, 0, n-1);

    for(int i = 0; i < n; i++) printf("%d ", q[i]);

    return 0;
}

```



## 归并排序

O(N*logN)

```c++
public static void merge_sort(int a[],int first,int last,int temp[]){

  if(first < last){
      int middle = (first + last)/2;
      merge_sort(a,first,middle,temp);//左半部分排好序
      merge_sort(a,middle+1,last,temp);//右半部分排好序
      mergeArray(a,first,middle,last,temp); //合并左右部分
  }
}

public static void mergeArray(int a[],int first,int middle,int end,int temp[]){     
  int i = first;
  int m = middle;
  int j = middle+1;
  int n = end;
  int k = 0; 
  while(i<=m && j<=n){
      if(a[i] <= a[j]){
          temp[k] = a[i];
          k++;
          i++;
      }else{
          temp[k] = a[j];
          k++;
          j++;
      }
  }     
  while(i<=m){
      temp[k] = a[i];
      k++;
      i++;
  }     
  while(j<=n){
      temp[k] = a[j];
      k++;
      j++; 
  }

  for(int ii=0;ii<k;ii++){
      a[first + ii] = temp[ii];
  }
}
```



## 堆排序

O(N*logN)

```java
public static void MakeMinHeap(int a[], int n){
 for(int i=(n-1)/2 ; i>=0 ; i--){
     MinHeapFixdown(a,i,n);
 }
}
//从i节点开始调整,n为节点总数 从0开始计算 i节点的子节点为 2*i+1, 2*i+2  
public static void MinHeapFixdown(int a[],int i,int n){

   int j = 2*i+1; //子节点
   int temp = 0;

   while(j<n){
       //在左右子节点中寻找最小的
       if(j+1<n && a[j+1]<a[j]){   
           j++;
       }

       if(a[i] <= a[j])
           break;

       //较大节点下移
       temp = a[i];
       a[i] = a[j];
       a[j] = temp;

       i = j;
       j = 2*i+1;
   }
}

public static void MinHeap_Sort(int a[],int n){
  int temp = 0;
  MakeMinHeap(a,n);

  for(int i=n-1;i>0;i--){
      temp = a[0];
      a[0] = a[i];
      a[i] = temp; 
      MinHeapFixdown(a,0,i);
  }     
}
```



## 基数排序

O(d(n+r))

```java
public static void RadixSort(int A[],int temp[],int n,int k,int r,int cnt[]){

   //A:原数组
   //temp:临时数组
   //n:序列的数字个数
   //k:最大的位数2
   //r:基数10
   //cnt:存储bin[i]的个数

   for(int i=0 , rtok=1; i<k ; i++ ,rtok = rtok*r){

       //初始化
       for(int j=0;j<r;j++){
           cnt[j] = 0;
       }
       //计算每个箱子的数字个数
       for(int j=0;j<n;j++){
           cnt[(A[j]/rtok)%r]++;
       }
       //cnt[j]的个数修改为前j个箱子一共有几个数字
       for(int j=1;j<r;j++){
           cnt[j] = cnt[j-1] + cnt[j];
       }
       for(int j = n-1;j>=0;j--){      //重点理解
           cnt[(A[j]/rtok)%r]--;
           temp[cnt[(A[j]/rtok)%r]] = A[j];
       }
       for(int j=0;j<n;j++){
           A[j] = temp[j];
       }
   }
}
```

# 第二章：其他基本算法

## Sort函数

基本用法略。

cmp函数 - 结构体排序：

```c++
struct Student{
    char name[];
    char id;
    in score;
    int r;
}stu[]

bool cmp(Student a, Student b){
    if (a.score != b,score) return a.score > b.score;
    else return strcmp(a.name, b,name) < 0;
}
// strcmp函数为比较两个char数组的大小， 参数1的字典序小于参数2的时候返回负数
```



一般比较：

```c
bool cmp(int &x,int &y){ 
　　return x>y;//意味着x>y的时候，把x放到y前,按大到小排序。 
}
```



注意 有些特殊情况下需要加结构体

```c
struct 结构名{
     bool operator()(const T &a1, const T &a2){
          return    ;
     } 
};
```



## 简单贪心

PAT B1020

```c
#include <iostream>
#include <algorithm>
#include <cstdio>
using namespace std;
 
struct mooncake {
    double store ;//库存总量
    double price ;//单价
    double sell ; //总售价
}cake[1010];
 
bool cmp(mooncake a,mooncake b){
    return a.price > b.price;
}
int main()
{
    int n;                  //月饼种类
    double D;               //需求量
 
    scanf("%d%lf",&n,&D);
    for(int i=0; i<n ; i++){
        scanf("%lf",&cake[i].store);
    }
 
    for (int i=0; i<n ; i++){
        scanf("%lf",&cake[i].sell);
        cake[i].price = cake[i].sell / cake[i].store ;      //计算单价
    }
    sort(cake,cake+n,cmp);   //从高到低排序
    double totalprice=0;     //总利润
    for(int i=0; i<n; i++){
        if (cake[i].store>D){
            totalprice=totalprice+D*cake[i].price;
            break;
        }else{
            D=D-cake[i].store;
            totalprice=totalprice+cake[i].store*cake[i].price;
 
        }
    }
    printf("%.2f\n",totalprice);
//    cout << "Hello world!" << endl;
    return 0;
}

```



## 区间贪心

见 《算法笔记》P123

## 二分

经典二分法:

```c
int ~(int *A, int left, int right, int x){
    int mid;
    while (left <= right){
        mid = (left + right) / 2;
        if (A[mid] == x) return mid;
        else if (A[mid] > x) right = mid - 1;
        else left = mid + 1;
    }
    return -1;
}
```



# 第 章：动态规划

动态规划的时间复杂度为 ： 状态数量 * 每一个状态所需要的计算时间。

## 0：背包问题系列

### **01背包**

有 N件物品和一个容量是 m的背包。每件物品只能使用一次。

第 ii 件物品的体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

输入格式

第一行两个整数，N，VN，V，用空格隔开，分别表示物品数量和背包容积。

接下来有 N 行，每行两个整数 vi,w ivi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。

输出格式

输出一个整数，表示最大价值。

数据范围

0<N,V≤10000<N,V≤1000
0<vi,wi≤1000

**二维写法：**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;

int n, m;
int v[N], w[N];
int f[N][N];

int main(){
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    for (int i = 1; i <= n; i++)
        for (int j = 0; j <= m; j++){
            f[i][j] = f[i-1][j];
            if (j >= v[i]) f[i][j] = max(f[i][j], f[i-1][j - v[i]] + w[i]);
        }
    cout << f[n][m] <<endl;
    return 0;
}
```

**一维写法：**

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 1010;

int n, m;
int v[N], w[N];
int f[N];

int main(){
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    
    for (int i = 1; i <= n; i++)
        for (int j = m; j >= v[i]; j--){
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    cout << f[m] <<endl;
    return 0;
}
```

### 完全背包：

有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。

第 i 种物品的体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

输入格式

第一行两个整数，N V，用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 种物品的体积和价值。

输出格式

输出一个整数，表示最大价值。

数据范围

0<N,V≤10000<N,V≤1000
0<vi,wi≤1000

**二维写法：**

```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 5010;
int n, m;
int v[N], w[N];
int f[N][N];

int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];
	
	for (int i = 1; i <= n; i++)
		for (int j = 0; j <= m; j++)
			for (int k = 0 ; k * v[i] <= j; k++)
				f[i][j] = max(f[i][j], f[i-1][j-v[i]*k] + w[i] * k);
	cout << f[n][m] <<endl;
	return 0;
}
```

一维写法：

```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 5010;
int n, m;
int v[N], w[N];
int f[N];

int main() {
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];
	
	for (int i = 1; i <= n; i++)
		for (int j = v[i]; j <= m; j++)
				f[j] = max(f[j], f[j-v[i]] + w[i]);
	cout << "max="<< f[m] <<endl;
	return 0;
}
```



## 1：线性DP

**经典题目1： 数字三角形**

```c++
给定如下的三角形， 顶部出发可以向左下或者右下移动，一直到底层，要求找出一条路径，使得路径上的数字和最大。
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5

分析：
    2个角度， 1 ： 状态表示: 二维集合i,j], 所有从起点， 走到(i, j)的路径
属性：所有路径上的最大值。也就是集合表示的最大值。
状态计算： 分成两类， 1 来自左上方。 2 来自右上方。
如果当前的状态为i,j， 那么用之前的来表示就是i-1, j-1 + a[i j],这是左上， 那么右上方就是i - 1, j + a[i j]
那么f[i, j]就是两个取一个最大值。

代码：
        
#include<bits/stdc++.h>
using namespace std;

int n, m;
int inf = 1e9;
int a[510][510];
int f[510][510];
int main(){
    cin >> n;
    for (int i = 1; i <= n; i++ )
    for (int j = 1; j <= n; j++)
    cin >> a[i][j];
	for (int i = 0 ; i < n; i++){
		for (int j = 0; j <= i + 1; j++){
			f[i][j] = -inf;
		}
	}
    f[1][1] = a[1][1];
    
    for (int i = 2; i <= n; i++){
    	for (int j = 1; j <= i; j++){
    		f[i][j] = max(f[i-1][j-1] + a[i][j], f[i-1][j] + a[i][j]);
		}
	}
	int res = -inf;
	for (int i = 1; i <= n; i++) res = max(res, f[n][i]);
	cout << res <<endl;
    return 0;
}
```



**经典题目2：最长上升子序列 ①（数据规模较小）**

给定一个长度为N的数列，求数值严格单调递增的子序列的长度最长是多少。

输出一个整数， 表示最大长度。

7

3 1 2 1 8 5 6

结果是 4， 也就是 1 2 5 6。

状态表示可以用一维数组， f[i], 所有以第 i个数为结尾的上升子序列的集合。

属性就是集合中所有以i结尾的上升子序列长度的最大值。

```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 1010;
int n, maxz;
int a[N], f[N];
int main(){
	scanf("%d", &n);
	for (int i = 1; i <= n ; i++) cin >> a[i];
	for (int i = 1; i <= n; i++){
		f[i] = 1;//只有a[i]一个数字 
		for (int j = 1; j < i; j++){
			if (a[j] < a[i]){
				f[i] = max(f[i], f[j] + 1);
				maxz = max(maxz, f[i]);
			}
		}
	}
	cout << maxz <<endl;
    return 0;
}
```

**经典题目3：最长公共子序列**

给定两个长度分别为N和M的字符串A和B， 求既是A的子序列又是B的子序列的字符串长度

最长是多少？

输出一个整数， 表示最大长度。

1 <= N <= 1000

f[i, j]表示的集合是 ： 第1个序列的前i个字母 和 且第二个序列的前 j 个字母出现的子序列

，属性显然是最大值。

```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 1010;
int n, m;
char a[N], b[N];
int f[N][N];
int main(){
	cin >> n >>m;
	scanf("%s%s", a+1, b+1);
	for (int i = 1; i <= n; i++){
		for (int j = 1; j <= m; j++){
			f[i][j] = max(f[i-1][j], f[i][j-1]);
			if (a[i] == b[j]) f[i][j] = max(f[i][j], f[i-1][j-1] + 1);
		}
	}
	cout <<f[n][m]; 
    return 0;
}

//或者

#include <bits/stdc++.h>
using namespace std;
int dp[1005][1005];
int main(){
    string s1,s2;
    cin>>s1>>s2;
    for(int i=1;i<=s1.size();i++){
        for(int j=1;j<=s2.size();j++){
            if(s1[i-1]==s2[j-1]){
                dp[i][j]=dp[i-1][j-1]+1;
            }else{
                dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
            }
        }
    }
    cout<<dp[s1.size()][s2.size()]<<endl;
    return 0;
}
```

## 2：区间DP

经典题目：石子合并

- 描述

    有N堆石子排成一排，每堆石子有一定的数量。现要将N堆石子并成为一堆。合并的过程只能每次将相邻的两堆石子堆成一堆，每次合并花费的代价为这两堆石子的和，经过N-1次合并后成为一堆。求出总的代价最小值。

 输入

有多组测试数据，输入到文件结束。 每组测试数据第一行有一个整数n，表示有n堆石子。 接下来的一行有n（0< n <200）个数，分别表示这n堆石子的数目，用空格隔开

- 输出

  输出总代价的最小值，占单独的一行

- 样例输入

  `3 1 2 3 7 13 7 8 16 21 4 18`

- 样例输出

  `9 239`

```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 1010;
int n;
int s[N];
int f[N][N];
int main(){
	cin >> n;
	for (int i = 1; i <= n; i++) cin >>s[i];
	for (int i = 1; i <= n; i++) s[i] += s[i-1];
	for (int len = 2; len <= n; len++){
		for (int i = 1; i+len-1<=n; i++){
			int l = i, r = i + len - 1;
			f[l][r] = 1e8;
			for (int k = l; k < r; k++)
			f[l][r] = min(f[l][r], f[l][k] + f[k+1][r] + s[r] - s[l - 1]);
		}
	}
	cout << f[1][n];
    return 0;
}
```

# 第 章：与树相关的

## 1：并查集

​		用于处理一些不相加集合的合并和查询问题。在使用中常常以森林来表示。并查集的核心思想是记录每个结点的父亲结点是哪个结点。

**1) 初始化:初始的时候每个结点各自为一个集合,father[i]表示结点 i 的父亲结点,如果 father[i]=i,我们认为这个结点是当前集合根结点。**

```c++
void init() {
    for (int i = 1; i <= n; ++i) {
        father[i] = i;
    }
}

```

**2) 查找:查找结点所在集合的根结点,结点 x 的根结点必然也是其父亲结点的根结点。**

```c++
int get(int x) {
    if (father[x] == x) { // x 结点就是根结点
        return x; 
    }
    return get(father[x]); // 返回父结点的根结点
}

```

**3) 合并:将两个元素所在的集合合并在一起,通常来说,合并之前先判断两个元素是否属于同一集合。**

```c++
void merge(int x, int y) {
    x = get(x);
    y = get(y);
    if (x != y) { // 不在同一个集合
        father[y] = x;
    }
}

```

上面三个操作是并查集常用的操作



**关于路径压缩：**

**我们只关心每个结点的父结点，而并不太关心树的真正的结构。这样我们在一次查询的时候，可以把查询路径上的所有结点的father[i]都赋值成为根结点。只需要在我们之前的查询函数上面进行很小的改动**

```c++
int get(int x) {
    if (father[x] == x) { // x 结点就是根结点
        return x; 
    }
    return father[x] = get(father[x]); // 返回父结点的根结点，并另当前结点父结点直接为根结点
}

```



例题：

```c++
找朋友

在社交的过程中，通过朋友，也能认识新的朋友。在某个朋友关系图中，假定 A 和 B 是朋友，B 和 C 是朋友，那么 A 和 C 也会成为朋友。即，我们规定朋友的朋友也是朋友。

现在，已知若干对朋友关系，询问某两个人是不是朋友。

请编写一个程序来解决这个问题吧。

输入格式
第一行：三个整数 n,m,p(n≤5000,m≤5000,p≤5000)分别表示有n 个人，m 个朋友关系，询问p 对朋友关系。

接下来 m 行：每行两个数Ai,Bi1≤Ai,Bi≤N，表示Ai​ 和 Bi具有朋友关系。

接下来 p 行：每行两个数，询问两人是否为朋友。

输出格式
输出共 p 行，每行一个Yes或No。表示第i个询问的答案为是否朋友。

#include<bits/stdc++.h>
using namespace std;

const int N = 5010;
int n, m, p;
int mark[N], fa[N];
int a, b;

int get(int x){
	if (fa[x] == x) return x;
	return fa[x] = get(fa[x]);
}

int main(){
	cin >> n >> m >> p;
	for (int i = 1; i <= n; i++) fa[i] = i; 
	while (m--){
		cin >> a >> b;
		a = get(a);
		b = get(b);
		if (a != b) fa[a] = b;
	}
	for (int i = 1; i <= p; i++){
		cin >> a >> b;
		a = get(a);
		b = get(b);
		if (a == b)
		mark[i] = 1;
	}
	for (int i = 1; i <= p; i++){
		if (mark[i]) cout << "yes" <<endl;
		else cout << "no" << endl;
	}
    return 0;
}
```

